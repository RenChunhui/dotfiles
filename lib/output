#!/bin/sh
#
# Output

ask() {
  echo ${GREEN}${ICON_ASK}${RESET} $1 ${DIM}$2${RESET_DIM}
}

info() {
  echo ${CYAN}${ICON_INFO}${RESET} $1
}

ok() {
  echo ${GREEN}${ICON_OK}${RESET} $1
}

warn() {
  echo ${YELLOW}${ICON_WARN}${RESET} $1
}

fail() {
  echo ${RED}${ICON_FAIL}${RESET} $1
}

choice() {
  read -r -p "${GREEN}?${RESET} $1 ${DIM}[y|N]${RESET_DIM}" response
  if [[ $response =~ (n|N) ]]; then
    exit;
  fi
}

radio() {
  ESC=$( printf "\033")
  cursor_blink_on()  { printf "${ESC}[?25h"; }
  cursor_blink_off() { printf "${ESC}}[?25l"; }
  cursor_to()        { printf "${ESC}}[$1;${2:-1}H"; }
  print_option()     { printf "  $1"; }
  print_selected()   { printf "${CYAN}${ICON_ARROR_RIGHT} $1${RESET}"; }
  get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
  key_input()        { read -s -n3 key 2>/dev/null >&2
                        if [[ $key = ${ESC}[A ]]; then echo up;    fi
                        if [[ $key = ${ESC}[B ]]; then echo down;  fi
                        if [[ $key = ""     ]]; then echo enter; fi; }

  for opt; do printf "\n"; done

  local lastrow=`get_cursor_row`
  local startrow=$(($lastrow - $#))

  trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
  cursor_blink_off

  local selected=0
    while true; do
      # print options by overwriting the last lines
      local idx=0
      for opt; do
        cursor_to $(($startrow + $idx))
        if [ $idx -eq $selected ]; then
          print_selected "$opt"
        else
          print_option "$opt"
        fi
        ((idx++))
      done

      # user key control
      case `key_input` in
        enter) break;;
        up)    ((selected--));
            if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
        down)  ((selected++));
            if [ $selected -ge $# ]; then selected=0; fi;;
      esac
  done

  cursor_to $lastrow
  printf "\n"
  cursor_blink_on

  return $selected
}

select_option() {
    # little helpers for terminal print control and key input
    ESC=$( printf "\033")
    cursor_blink_on()  { printf "$ESC[?25h"; }
    cursor_blink_off() { printf "$ESC[?25l"; }
    cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
    print_option()     { printf "  $1"; }
    print_selected()   { printf "${CYAN}â–¸ $1${END}"; }
    get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
    key_input()        { read -s -n3 key 2>/dev/null >&2
                         if [[ $key = $ESC[A ]]; then echo up;    fi
                         if [[ $key = $ESC[B ]]; then echo down;  fi
                         if [[ $key = ""     ]]; then echo enter; fi; }

    # initially print empty new lines (scroll down if at bottom of screen)
    for opt; do printf "\n"; done

    # determine current screen position for overwriting the options
    local lastrow=`get_cursor_row`
    local startrow=$(($lastrow - $#))

    # ensure cursor and input echoing back on upon a ctrl+c during read -s
    trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
    cursor_blink_off

    local selected=0
    while true; do
        # print options by overwriting the last lines
        local idx=0
        for opt; do
            cursor_to $(($startrow + $idx))
            if [ $idx -eq $selected ]; then
                print_selected "$opt"
            else
                print_option "$opt"
            fi
            ((idx++))
        done

        # user key control
        case `key_input` in
            enter) break;;
            up)    ((selected--));
                   if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
            down)  ((selected++));
                   if [ $selected -ge $# ]; then selected=0; fi;;
        esac
    done

    # cursor position back to normal
    cursor_to $lastrow
    printf "\n"
    cursor_blink_on

    return $selected
}
